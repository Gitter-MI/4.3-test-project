{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang2057{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang7 # 1. Structured Scene and Node Hierarchy Documentation\par
\par
## Hierarchical Overview\par
\par
**Main Scene** (Node2D)\par
- **Building Scene** (Node2D) *(attached script: `building.gd`)*\par
  - **Floor Scenes** *(instantiated at runtime)*\par
    - **Floor_X** (Area2D)\par
      - **FloorSprite** (Sprite2D)\par
      - **CollisionShape2D** (RectangleShape2D)\par
      - **Marker2D**\par
      - **Doors** *(instantiated at runtime)*\par
        - **Door** (Area2D) *(attached script: `door.gd`)*\par
          - **AnimatedSprite2D**\par
          - **CollisionShape2D**\par
          - **Label**\par
- **Sprite Scene**\par
\par
## Brief Descriptions\par
\par
- **Main Scene** (Node2D): The root scene that initializes the game and serves as the entry point.\par
\par
- **Building Scene** (Node2D): Manages the generation and configuration of building floors and doors using the `building.gd` script.\par
  - **Floor Scenes**: A collection of floor instances (`floor_0`, `floor_1`, etc.) that are dynamically loaded and added to the building.\par
    - **Floor_X** (Area2D): Represents an individual floor in the building.\par
      - **FloorSprite** (Sprite2D): Visual representation of the floor.\par
      - **CollisionShape2D** (RectangleShape2D): Defines the collision area for physics interactions on the floor.\par
      - **Marker2D**: Serves as a reference point for positioning doors and other elements on the floor.\par
      - **Doors**: Doors are instantiated at runtime based on the data provided in `DoorData.gd`.\par
        - **Door** (Area2D): Represents a door on a floor, managed by the `door.gd` script.\par
          - **AnimatedSprite2D**: Visual representation of the door with animation capabilities.\par
          - **CollisionShape2D**: Defines the collision area of the door for interaction detection.\par
          - **Label**: Displays information such as the door number or owner.\par
- **Sprite Scene**: [Purpose to be defined; likely contains additional sprites or UI elements used in the game.]\par
\par
- **DoorData.gd** (Resource): A custom resource script that contains an array of door data dictionaries. Each dictionary holds properties like `index`, `floor_number`, `door_slot`, `door_type`, `owner`, and `tooltip`, which are used to configure doors during building generation.\par
\par
---\par
\par
**Note:** The `building.gd` script is responsible for:\par
- Preloading floor scenes and door data.\par
- Generating the building by instantiating floors and positioning them appropriately.\par
- Adding doors to each floor based on the data from `DoorData.gd`.\par
- Configuring collision shapes and markers for floors to ensure proper physics interactions and positioning.\par
\par
The `door.gd` script handles:\par
- Configuring individual doors based on provided data.\par
- Managing door states (open or closed) and updating animations accordingly.\par
- Setting up collision shapes for doors to enable interaction.\line\line\line ## 2. Script Summaries and Responsibilities\par
\par
### High-Level Overviews\par
\par
- **`building.gd`**:\par
  - **Purpose**: Manages the procedural generation of the building, including the instantiation and positioning of floors and doors. It loads floor scenes and door data, configures collision shapes and markers for floors, and adds doors to each floor based on predefined data in `DoorData.gd`.\par
\par
- **`door.gd`**:\par
  - **Purpose**: Controls the behavior of individual doors within the building. It handles door configuration based on provided data, manages door states (open/closed), updates animations accordingly, and sets up collision shapes for interaction detection.\par
\par
- **`DoorData.gd`**:\par
  - **Purpose**: Acts as a custom resource that stores an array of door data dictionaries. Each dictionary contains properties necessary for configuring doors, such as `index`, `floor_number`, `door_slot`, `door_type`, `owner`, and `tooltip`.\par
\par
### Function Descriptions\par
\par
#### **`building.gd`**\par
\par
- **`_ready()`**:\par
  - **Description**: Entry point function that initializes door data and triggers the building generation process by calling `generate_building()`.\par
\par
- **`generate_building()`**:\par
  - **Description**: Core function that iterates through preloaded floor scenes, instantiates each floor, positions them appropriately, configures collision shapes and markers, and adds doors to each floor.\par
\par
- **`instantiate_floor(scene)`**:\par
  - **Description**: Instantiates a floor scene and adds it as a child to the building node. Returns the floor instance for further configuration.\par
\par
- **`position_floor(floor_instance, previous_floor_top_y_position, is_first_floor)`**:\par
  - **Description**: Calculates and sets the position of a floor instance based on the position of the previous floor and whether it's the first floor.\par
\par
- **`configure_collision_shape(floor_instance)`**:\par
  - **Description**: Configures the `CollisionShape2D` of a floor to match the visual boundaries defined by the floor sprite, ensuring accurate physics interactions.\par
\par
- **`configure_marker(floor_instance)`**:\par
  - **Description**: Positions the `Marker2D` node at the bottom edge of the floor sprite to serve as a reference point for door placement.\par
\par
- **`add_doors_to_floor(floor_instance, floor_index)`**:\par
  - **Description**: Filters the door data for the current floor and instantiates doors at their respective slots using `get_door_slot_position()` and `configure_door()`.\par
\par
- **`get_door_slot_position(floor_instance, slot_index)`**:\par
  - **Description**: Calculates the precise position for a door on a floor based on slot index, floor dimensions, and predefined slot percentages.\par
\par
- **`configure_door(door_instance, door_data)`**:\par
  - **Description**: Passes door configuration data to the door instance, allowing it to set up its appearance and properties accordingly.\par
\par
- **`get_door_dimensions()`**:\par
  - **Description**: Retrieves the width and height of the door sprite to assist in accurate positioning and collision shape configuration.\par
\par
- **Helper Functions**:\par
  - **`get_door_height_offset()`**:\par
    - **Description**: Calculates the vertical offset needed to align the door correctly with the floor marker.\par
  - **`get_floor_height(floor_instance)`**:\par
    - **Description**: Retrieves the height of a floor instance for positioning calculations.\par
\par
#### **`door.gd`**\par
\par
- **`_ready()`**:\par
  - **Description**: Initializes the door by calling `setup_door()` upon instantiation.\par
\par
- **`setup_door()`**:\par
  - **Description**: Ensures all required nodes (`AnimatedSprite2D` and `CollisionShape2D`) are present and sets the door to its initial closed state.\par
\par
- **`configure(door_data)`**:\par
  - **Description**: Configures the door's properties based on the provided door data, such as setting the door type and updating the collision shape.\par
\par
- **`set_door_state(new_state)`**:\par
  - **Description**: Changes the door's state between open and closed, updating the animation to reflect the current state.\par
\par
- **`update_collision_shape()`**:\par
  - **Description**: Adjusts the door's collision shape based on its current sprite dimensions and scale, ensuring accurate interaction detection.\par
\par
#### **`DoorData.gd`**\par
\par
- **Properties**:\par
  - **`doors`**:\par
    - **Description**: An exported array of dictionaries where each dictionary represents a door's configuration data, including:\par
      - `index`: Unique identifier for the door.\par
      - `floor_number`: The floor on which the door is located.\par
      - `door_slot`: The position slot index on the floor.\par
      - `door_type`: The visual style or type of the door.\par
      - `owner`: The designated owner of the room behind the door.\par
      - `tooltip`: Additional information to display when interacting with the door.\par
\par
\par
\par
\line # 3. Resource and Data Structures Documentation\par
\par
## Custom Resources\par
\par
### **DoorData.gd**\par
\par
- **Purpose**: `DoorData.gd` is a custom resource script that serves as a centralized data store for door configurations within the building. It contains an array of dictionaries, each representing a door's properties. This resource allows for easy management and modification of door data without altering the main scripts.\par
\par
- **Structure**: The resource extends the `Resource` class and is assigned the `class_name` `DoorData`. It exports an array called `doors`, which holds dictionaries containing all the necessary properties for each door.\par
\par
  ```gdscript\par
  # DoorData.gd\par
  extends Resource\par
  class_name DoorData\par
\par
  @export var doors: Array[Dictionary] = []\par
  ```\par
\par
## Data Field Definitions\par
\par
Each door in the `doors` array is a dictionary with the following fields:\par
\par
- **`index`** *(int)*:\par
  - **Description**: A unique identifier for the door. This can be used for tracking or referencing specific doors within the game logic.\par
  \par
- **`floor_number`** *(int)*:\par
  - **Description**: Indicates the floor on which the door is located. This helps the `building.gd` script place doors on the correct floor during building generation.\par
  \par
- **`door_slot`** *(int)*:\par
  - **Description**: Specifies the slot position on the floor where the door should be placed. Slots correspond to predefined percentages along the floor's width to ensure consistent positioning.\par
  \par
- **`door_type`** *(int)*:\par
  - **Description**: Determines the visual appearance or style of the door. Different types can represent various room functions or statuses.\par
  \par
- **`owner`** *(String)*:\par
  - **Description**: The designated owner of the room behind the door. This can be a player, NPC, or entity relevant to the game's context.\par
  \par
- **`tooltip`** *(String)*:\par
  - **Description**: Additional information displayed when interacting with the door, such as room descriptions or hints.\par
\par
## DoorData.tres Example\par
\par
An excerpt from the `DoorData.tres` resource file demonstrates how door data is structured:\par
\par
```gd\par
[gd_resource type="Resource" script_class="DoorData" load_steps=2 format=3 uid="uid://..."]\par
\par
[ext_resource type="Script" path="res://DoorData.gd" id="1"]\par
\par
[resource]\par
script = ExtResource("1")\par
doors = Array[Dictionary]([\par
  \{\par
    "index": 0,\par
    "floor_number": 1,\par
    "door_slot": 0,\par
    "door_type": 1,\par
    "owner": "Player 1",\par
    "tooltip": "This is your office."\par
  \},\par
  \{\par
    "index": 1,\par
    "floor_number": 1,\par
    "door_slot": 1,\par
    "door_type": 2,\par
    "owner": "Player 1",\par
    "tooltip": "This is your newsroom."\par
  \},\par
  // Additional door entries...\par
])\par
```\par
\par
- **Explanation**:\par
  - Each dictionary within the `doors` array represents a single door.\par
  - The `index` ensures each door can be uniquely identified.\par
  - `floor_number` associates the door with a specific floor.\par
  - `door_slot` determines the door's horizontal position on the floor.\par
  - `door_type` selects the door's visual style.\par
  - `owner` and `tooltip` provide contextual information for gameplay and interaction.\par
\par
## Integration with Scripts\par
\par
- **In `building.gd`**:\par
  - The `DOOR_DATA_RESOURCE` is preloaded and accessed during the `_ready()` function.\par
  - The script iterates over `door_data.doors` to instantiate and configure each door according to the provided data.\par
  - Functions like `add_doors_to_floor()` and `configure_door()` utilize the fields from each door dictionary to place and customize doors appropriately.\par
\par
- **In `door.gd`**:\par
  - The `configure(door_data)` function receives a door's dictionary and sets up the door's properties.\par
  - The `door_type` field is used to determine which animation to display.\par
  - `owner` and `tooltip` can be used to set labels or interactive text for the player.\par
\par
\par
4. Flow of Execution and Interaction\par
Process Overview\par
\par
Upon starting the game, the following sequence of events unfolds to generate the building and its interactive elements:\par
\par
    Initialization:\par
        The Main Scene (Node2D) is loaded as the root node of the game.\par
        Within the Main Scene, the Building Scene (Node2D) is instantiated. This scene has the building.gd script attached, which manages the building's generation.\par
\par
    Building Generation:\par
        Door Data Loading:\par
            In the _ready() function of building.gd, the script preloads the DoorData.tres resource, which contains an array of door configurations defined in DoorData.gd.\par
        Floor Scene Preloading:\par
            All floor scenes (floor_0.tscn, floor_1.tscn, etc.) are preloaded into the FLOOR_SCENES array for efficient instantiation.\par
        Construction Process:\par
            The generate_building() function is called to start building the structure.\par
            Floor Instantiation and Positioning:\par
                The script iterates over each floor scene in FLOOR_SCENES.\par
                Each floor is instantiated using instantiate_floor(), positioned correctly with position_floor(), and added as a child to the Building Scene.\par
                Collision shapes and markers are configured for each floor using configure_collision_shape() and configure_marker() to ensure accurate physics interactions and door placements.\par
        Door Placement:\par
            For each floor, add_doors_to_floor() is called with the floor instance and its index.\par
            The function filters the doors array in DoorData.tres to retrieve doors assigned to the current floor.\par
            Door Instantiation:\par
                Each door is instantiated from the Door.tscn scene.\par
                The position for each door is calculated using get_door_slot_position(), which uses predefined slot percentages and floor dimensions.\par
                The door instance is added as a child to the floor instance.\par
            Door Configuration:\par
                configure_door() is called for each door, passing the specific door data dictionary.\par
                This allows each door to set up its properties like door type, owner, and tooltip.\par
\par
    Door Setup:\par
        Each door runs the door.gd script upon instantiation.\par
        Initial Configuration:\par
            The _ready() function calls setup_door(), ensuring all required nodes are present and setting the door to its initial closed state.\par
        Applying Door Data:\par
            The configure() function applies the door data to the door instance.\par
            It sets the door_type, updates animations, and adjusts the collision shape to match the door's appearance.\par
\par
    Completion:\par
        Once all floors and doors are instantiated and configured, the building generation is complete.\par
        The fully constructed building with all interactive elements is now visible to the player.\par
\par
Interaction Points\par
\par
The game includes interactive elements that respond to player actions:\par
\par
    Door Interaction:\par
        Collision Detection:\par
            Each door is an Area2D node with a CollisionShape2D, enabling it to detect when the player or other objects enter its area.\par
        State Changes:\par
            The door's state (open or closed) is managed by the set_door_state() function in door.gd.\par
            Interacting with a door can trigger it to change state:\par
                Opening a Door:\par
                    The door's AnimatedSprite2D plays the open animation.\par
                    The collision shape can be adjusted or disabled to allow passage.\par
                Closing a Door:\par
                    The door reverts to the closed animation.\par
                    The collision shape is re-enabled to block passage.\par
        User Interaction:\par
            While the exact method of interaction (e.g., clicking, pressing a key) is to be implemented, doors are designed to respond to player inputs.\par
            Tooltips or labels can display information when the player is near or interacts with the door, utilizing the tooltip and owner fields from the door data.\par
\par
    Floor Navigation:\par
        Movement Between Floors:\par
            As the player moves through the building, they can navigate between floors.\par
            Collision shapes on floors prevent the player from moving outside the building boundaries.\par
            Markers:\par
                Marker2D nodes on each floor can serve as reference points for elevators, stairs, or other navigation aids in future implementations.\par
\par
    Potential Enhancements:\par
        Interactive Elements:\par
            Additional interactive objects (e.g., elevators, NPCs) can be added to floors using a similar instantiation and configuration approach.\par
        User Interface:\par
            The Sprite Scene can be utilized to display HUD elements or interact with the building (e.g., a floor selector).\par
        Events and Triggers:\par
            Area2D nodes can detect when the player enters specific zones, triggering events like messages or scripted sequences.\par
\par
Note: The current implementation focuses on the procedural generation of the building structure and the placement of doors with basic interactive capabilities. User interaction mechanics (e.g., player movement, input handling) are intended to be developed in future stages of the project.\par
\par
}
 